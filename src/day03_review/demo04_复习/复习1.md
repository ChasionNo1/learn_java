### 1、Java权限修饰符以及其他关键字的使用

权限修饰符：public/(default)/protected/private

4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类

修饰类的话，只能使用：缺省、public

局部变量不能使用权限修饰符

![image-20220122180953396](C:\Users\chasion\AppData\Roaming\Typora\typora-user-images\image-20220122180953396.png)

```java
public static void main(String[] args){//方法体}

权限修饰符：private 缺省 protected pubilc ---->封装性
修饰符：static \ final \ abstract \native 可以用来修饰方法
返回值类型： 无返回值 / 有返回值 -->return
方法名：需要满足标识符命名的规则、规范；"见名知意"
形参列表：重载 vs 重写；参数的值传递机制；体现对象的多态性
方法体：来体现方法的功能
```



### 2、属性赋值的先后顺序

```java
public class FiledTest {
    public static void main(String[] args) {
        Dog tom = new Dog("tom", 13);
        tom.setName("jack");
        System.out.println(tom);
    }

}

class Dog{
    // 默认初始化
    private String name;
    // 显示初始化和代码块初始化，看谁在前面，就先赋值
    {
        age = 13;
    }
    private int age = 12;
  

    public Dog() {
    }

    public Dog(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



 * ① 默认初始化
 * ② 显式初始化
 * ③ 构造器中初始化
 * ④ 通过对象.属性或者对象.方法的方式
 * ⑤ 在代码块中赋值
 * 以上操作的先后顺序：① - ②/⑤ - ③ - ④  

### 3、this关键字

##### 3.1 可以调用的结构：属性、方法；构造器

##### 3.2 this调用属性、方法：

this理解为：当前对象  或 当前正在创建的对象

在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

##### 3.3 this调用构造器：

① 我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器
② 构造器中不能通过"this(形参列表)"方式调用自己
③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
④ 规定："this(形参列表)"必须声明在当前构造器的首行
⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

### 4、子类重写父类方法的规则

方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
 * 						//方法体
 * 					}
 * 		约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
 * 		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
 *         ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
 *      	>特殊情况：子类不能重写父类中声明为private权限的方法
 *         ③ 返回值类型：
 *      	>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
 *      	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
 *      	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
 *		④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 *	 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。	

### 5、重写和重载的区别

① 二者的概念：
② 重载和重写的具体规则
③ 重载：不表现为多态性。
  重写：表现为多态性。
重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；

而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 

引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态“

方法重写的规则：

```java
方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{
     * 						//方法体
 * 						}
```
 * 		约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法
 * 		① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
 *         ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符
 *      	>特殊情况：子类不能重写父类中声明为private权限的方法
 *         ③ 返回值类型：
 *      	>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void
 *      	>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类
 *      	>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)
 * ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）
 *    子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。	

### 6、super关键字

##### 6.1 super 关键字可以理解为：父类的

##### 6.2 可以用来调用的结构：属性、方法、构造器

##### 6.3 super调用属性、方法：

6.3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."

6.3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。
6.3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

##### 6.4 super调用构造器：

6.4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器
64.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！
6.4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二一，不能同时出现
6.4.4 在构造器的首行，没显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()
6.4.5 在类的多个构造器中，至少一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

### 7、包装类、基本数据类型、String之间的转换

```java
// 基本数据类型 ---> 包装类
Integer integer = new Integer(12);
// 包装类 ---> 基本数据类型
int i = integer.intValue();
// 基本数据类型 ---> String
String s1 = "" + 12;
String s2 = String.valueOf(12);
// String ---> 基本数据类型
int num = Integer.parseInt(s2);
// 包装类 ---> String
String s3 = integer.toString();
// String ---> 包装类
Float f = new Float("123F");
```

### 8、static关键字

##### 8.1 可以用来修饰的结构：主要用来修饰类的内部结构：属性、方法、代码块、内部类

##### 8.2 static修饰属性：静态变量（或类变量）

8.2.1 属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)
 * 		   实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。
 *           静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

8.2.2 static修饰属性的其他说明：

① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用

② 静态变量的加载要早于对象的创建。

③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。



④		类变量	实例变量

类		   yes		   no

对象	   yes	 	  yes

##### 8.3 static修饰方法：静态方法、类方法

① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

②			          静态方法	非静态方法

类		 			 	  yes			no

对象						yes			yes

③ 静态方法中，只能调用静态的方法或属性非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

##### 8.4 static的注意点：

在静态的方法内，不能使用this关键字、super关键字

关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

### 9、单例模式

##### 9.1 饿汉式

```java
class Bank{
    // 1、私有化的构造器
    private Bank(){
        
    }
    //2.内部创建类的对象
	//4.要求此对象也必须声明为静态的
    private static Bank instance = new Bank();
    //3.提供公共的静态的方法，返回类的对象
    public static Bank getInstance(){
        return instance;
    }
}
```

##### 9.2 懒汉式

```java
class Bank{
    //1.私化类的构造器
    private Bank(){
        
    }
    //2.声明当前类对象，没初始化
	//4.此对象也必须声明为static的
    private static Bank instance = null;
    //3.声明public、static的返回当前类对象的方法
    public static Bank getInstance(){
        if(instance == null){
            instance = new Bank();
        }
        return instance;
    }
}
```

饿汉式：对象加载时间过长，但是是线程安全的

懒汉式：延迟创建对象，目前线程不安全

9.3 懒汉式线程安全

```java
class Bank{
    private Bank(){}
    private static Bank instance = null;
    public static Bank getInstance(){
        if (instance == null){
            synchronized (Bank.class){
                if (instance == null){
                    instance = new Bank();
                }
            }
        }
        return instance;
    }
}
```



### 10、final关键字

##### 10.1 可以用来修饰：类、方法、变量

final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类

final 用来修饰方法：表明此方法不可以被重写，比如：Object类中getClass();

final 用来修饰变量：此时的"变量"就称为是一个常量

final修饰属性：

可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化

final修饰局部变量：

尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。

static final 用来修饰属性：全局常量

### 11、abstract关键字

##### 11.1 可以用来修饰：类、方法

##### 11.2 修饰类

抽象类， 此类不能实例化

> 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）

> 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 --->抽象的使用前提：继承性

##### 11.3 修饰方法

抽象方法

> 抽象方法只方法的声明，没方法体

> 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。

> 若子类重写了父类中的所的抽象方法后，此子类方可实例化；若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

##### 11.4 注意点：

abstract不能用来修饰：属性、构造器等结构

abstract不能用来修饰私方法、静态方法、final的方法、final的类

```java
public abstract class AA{}
default abstract class BB{}
class CC{
    public static final class dd{}
    
}

```

### 12、属性与局部变量

对比：属性  vs  局部变量

1.相同点：

 * 		1.1  定义变量的格式：数据类型  变量名 = 变量值
 * 		1.2 先声明，后使用
 * 		1.3 变量都其对应的作用域 

2.不同点：
		2.1 在类中声明的位置的不同

 * 		属性：直接定义在类的一对{}内
 * 		局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
 * 		
 * 		2.2 关于权限修饰符的不同
 * 		属性：可以在声明属性时，指明其权限，使用权限修饰符。
 * 			常用的权限修饰符：private、public、缺省、protected  --->封装性
 * 			目前，大家声明属性时，都使用缺省就可以了。
 * 		局部变量：不可以使用权限修饰符。
 * 
 * 		2.3 默认初始化值的情况：
 * 		属性：类的属性，根据其类型，都默认初始化值。
 * 			整型（byte、short、int、long：0）
 * 			浮点型（float、double：0.0）
 * 			字符型（char：0  （或'\u0000'））
 * 			布尔型（boolean：false）
 * 
 * 			引用数据类型（类、数组、接口：null）
 * 
 * 		局部变量：没默认初始化值。
 *  		意味着，我们在调用局部变量之前，一定要显式赋值。
 * 			特别地：形参在调用时，我们赋值即可。
 * 
 * 		2.4 在内存中加载的位置：
 * 		属性：加载到堆空间中   （非static）
 * 		局部变量：加载到栈空间
